classdef query_files_obj < handle
    %%% queryfs checks through all specified directories and returns
    %%% a structure containing data about the files found.
    %%%
    %%% Inputs
    %%% The function takes a structure with at least one field
    %%% (searchpaths) (see below for example)
    %%%
    %%%
    %%% Optional Inputs
    %%%             rootdir: Optional Input: Default = '', Prefix for all search paths e.g. '/imaging/camcan/cc280/mri/'
    %%%           listfound: Optional Input: Default = 0,  Lists all files found durng search
    %%%     selectfirstfile: Optional Input: Default = 0,  When multiple files are found set true to retrieve
    %%%                                                    the first in list otherwise show warning and return nothing
    %%%
    %%% Searches are constructed by placing tags into a search query
    %%% in the following way
    %%%     /path/to/data/<CCID>/filename_session1.fif
    %%%
    %%% In this example <CCID> replaces the CCID of the participant.
    %%%
    %%% If there is any inconsistency in the filename or filepath, replace with
    %%% a wildcard * as you would in linux ls commands.
    %%%
    %%% For example if the above example had 2 possible sessions, and you want
    %%% to find either session1 or session2, replace the part of the filename
    %%% that varies with a wildcard.
    %%%
    %%%     /path/to/data/<CCID/filename_session*.fif
    %%%
    %%% 700 Data
    %%%     <CCID> Searches 1 CCID per subject using upper case CC
    %%%     <ccID> Same as above but with lowercase cc (used in meg data folders)
    %%%     <MRIID> searches through all MRIID
    %%%     <MEGID> used only in the raw meg data files
    %%% 280 Data
    %%%     <MRI280ID> it is important to use this tag when searching 280 data based on MRIID (CBU######)
    %%%     <CC280ID> saves time using this tag since only 280 IDs are searched
    %%%
    %%% Output
    %%%     Q: A structure containing various variables.
    %%%         searchpaths: {'SessionLabel'  'filepath/...'}     % The original query
    %%%           fileindexmat: [708x1 logical]                      % Logical index indicating the existence of files matching the search query for each subject
    %%%             rootdir: ''                                   % Optional Input: Prefix for all search paths.
    %%%           listfound: 0                                    % Optional Input: Lists all files found durng search
    %%%     selectfirstfile: 0                                    % Optional Input: when multiple files are found set true to retrieve the first in list
    %%%       CorrectSubIDc: [1x1 struct]                         % Correct CBU IDs per result. Each query is contained in a separate field
    %%%           filenames: [1x1 struct]                         % Full file names without wildcards for each subject and each query
    %%%     fileindex: [1x1 struct]                         % Same as fileindexmat, but each query is contained in a separate field
    %%%            fileinfo: [1x1 struct]                         % Contains date created (as given by OS) for each file found
    %%%      allexist: [1x582 double]                       % Linear index for subjects that match all queries [same as find(all(obj.fileindexmat,2)) ]
    %%%
    %%%
    %%% Working Example: Simple:
    %%%     obj.searchpaths = {'MEG' '/imaging/camcan/cc700-meg/data/mf22_spm12_pipeline/release002/preproc/<CCID>/rest/autobad_sss_skip20_fl_rest.fif'}
    %%%     Q = CCQuery_CheckFiles(Q)
    %%%
    %%% Working Example: Complex: (2 ID types, and wildcard)
    %%%
    %%% Start with the path /imaging/camcan/cc280/mri/pipeline/release003/RestingState/aamod_smooth_00001/CBU130802/RestingState/sswarfMR13010_CC220974-0002.nii
    %%%
    %%% Confirm it exists for at least 1 subject
    %%%
    %%%     >> ls /imaging/camcan/cc280/mri/pipeline/release003/RestingState/aamod_smooth_00001/CBU130802/RestingState/sswarfMR13010_CC220974-0002.nii
    %%%
    %%% If it didn't exist you would see an error here
    %%%
    %%% Replace the parts that might vary with a wildcard (usually numbers generated by scanners etc may vary)
    %%%     /imaging/camcan/cc280/mri/pipeline/release003/RestingState/aamod_smooth_00001/CBU130802/RestingState/sswarfMR*_CC220974-0002.nii
    %%%
    %%% Replace the two IDs with tags (it is necessary to use 280 tags here)
    %%%     /imaging/camcan/cc280/mri/pipeline/release003/RestingState/aamod_smooth_00001/<MRI280ID>/RestingState/sswarfMR*_<CC280ID>-0002.nii
    %%%
    %%% Construct a query called "Smooth".
    %%%
    %%%     obj.searchpaths = {
    %%%         'Smooth' '/imaging/camcan/cc280/mri/pipeline/release003/RestingState/aamod_smooth_00001/<MRI280ID>/RestingState/sswarfMR*_<CC280ID>-0002.nii'
    %%%         };
    %%%     Q = CCQuery_CheckFiles(Q);
    %%%
    %%% View / get all filenames by typing
    %%% filenames = obj.filenames.Smooth
    %%%
    %%% Get only those files that exist
    %%% filenames = obj.filenames.Smooth(obj.fileindex.Smooth)
    %%%
    %%% Note: the best way to construct a search query is to ensure one of the
    %%% files exists. e.g. type
    %%%
    %%%     >> ls /imaging/camcan/cc700-meg/data/mf22_spm12_pipeline/release002/preproc/*/rest/autobad_sss_skip*.fif
    %%%
    %%% in the matlab command window. Then take one of the results and replace
    %%% the CC###### with the <CCID> tag.
    %%%
    %%% Darren Price. Last Updated (02/09/2017)
    
    properties
        selectfirstfile = false
        idlist = '';
        iddata
        idhead
        searchpaths = [];
        sublist = [];
        fileindexmat
        rootdir = '';
        debug = false;
        verbose = false;
        listfound = false;
        ID
        filenames
        fileindex
        dataflags
        fileinfo
        seriesnumbers
        allexist
    end
    
    %     methods (Hidden)
    %         function addlistener(obj, property, eventname, callback)
    %             addlistener@addlistener(obj, property, eventname, callback)
    %         end
    %     end
    
    methods
        function obj = query_files_obj(idlist, searchpaths)
            if nargin == 0
                error('At least one argument is required, idlist and optional searchpaths. See <a href="matlab:edit query_files_obj_example.m">query_files_obj_example.m</a>')
            elseif nargin == 1
                if exist(idlist,'file')
                    obj.idlist = idlist;
                else
                    error('queryfs:idlistnotfound', 'Could not find specified idlist %s', idlist)
                end
            else
                obj.searchpaths = searchpaths;
                obj.idlist = idlist;
                obj.checkfiles();
            end
        end
        
        function obj = addsearchpath(obj, name, path)
            if nargin == 1
                if iscell(name)
                    obj.searchpaths = name;
                else
                    error('When using only one input, argument 1 should be a cell array {''name'' ''searchpaths''}')
                end
            end
            
            if isempty(obj.searchpaths)
                obj.searchpaths = {name path};
            else
                if ~strcmp(obj.searchpaths(:,1), name)
                    obj.searchpaths = [obj.searchpaths; {name path}];
                else
                    error('queryfs:nameexists','Name %s already exists in the searchpaths', name)
                end
            end
        end
        
        function checkfiles(obj)
            
            obj.iddata = csvimport(obj.idlist,'outputAsChar',true);
            obj.idhead = obj.iddata(1,:);
            obj.iddata = obj.iddata(2:end, :);
            
            Nsubs = size(obj.iddata,1);%#ok<*USENS>
            
            if ~isempty(obj.idlist)
                obj.sublist = 1:Nsubs;
            end
            
            % Load dataflags
            % C = csvimport('dataflags.csv','delimiter','\t');
            
            % Check Files Exist.
            obj.fileindexmat = false(Nsubs,size(obj.searchpaths,1));
            
            if ~obj.verbose
                printprogCR = false;
            else
                printprogCR = true;
                obj.listfound = true;
            end
            
            % Validate search paths
            for sesi = 1:size(obj.searchpaths,1)
                sp = obj.searchpaths{sesi,2};
                if obj.debug == false
                    if isempty(regexp(sp, '<*>','ONCE'))
                        disp(['ERROR in: ' obj.searchpaths{sesi,1}])
                        error('No tag (i.e. <ID>) found in search string')
                    end
                end
            end
            
            for hi = 1:length(obj.idhead)
                obj.ID.(obj.idhead{hi}) = obj.iddata(:,hi);
            end
            
            for sesi = 1:size(obj.searchpaths,1)
                %     obj.CorrectSubIDc.(obj.searchpaths{sesi,1}) = cell(Nsubs,1); % will write right in to Q so set up cells. Also ensures output is always required size
                obj.filenames.(obj.searchpaths{sesi,1}) = cell(1,Nsubs);
                obj.fileindex.(obj.searchpaths{sesi,1}) = false(Nsubs,1);
                obj.dataflags.(obj.searchpaths{sesi,1}).Message = '';
                obj.dataflags.(obj.searchpaths{sesi,1}).Index = false(Nsubs,1);
                
                fprintf('\n\nChecking: %s', obj.searchpaths{sesi,1})
                
                if size(obj.searchpaths, 2) == 3
                    sesuse = obj.searchpaths{sesi,3}; % assign the session search list
                else
                    sesuse = 1:4;
                end
                
                for ii = obj.sublist
                    printProgress(ii, Nsubs, printprogCR)
                    
                    if obj.verbose == 1
                        disp(SubCCIDc{ii})
                    end
                    
                    Format = fullfile(obj.rootdir,obj.searchpaths{sesi,2});
                    [st, en] = regexpi(Format, '<([><A-Z|0-9]){1,}>');
                    
                    % Check which tags are in Format
                    %                     clear tags
                    %                     for ti = 1:length(st)
                    %                         tags{ti} = Format(st(ti)+1:en(ti)-1); %#ok<AGROW>
                    %                     end
                    
                    % Check which tags are in Format
                    tags = {};
                    tagsref = {};
                    tagsfmt = {};
                    for ti = 1:length(st)
                        tagstr = splitstring(Format(st(ti)+1:en(ti)-1),'|');
                        for tsi = 1:length(tagstr)
                            tags{end+1} = tagstr{tsi}; %#ok<AGROW>
                            tagsref{end+1} = obj.searchpaths{sesi,1}; %#ok<AGROW>
                            tagsfmt{end+1} = Format(st(ti)+1:en(ti)-1);  %#ok<AGROW> Associate this tag with the tag set
                        end
                    end
                    
                    tagmem = ismember(tags, obj.idhead);
                    if any(ismember(tags, obj.idhead) == 0)
                        error([
                            sprintf('The following tags were not found in ID list (%s) for session %s: ', obj.idlist, obj.searchpaths{sesi,1}),...
                            sprintf('<%s> ', tags{tagmem == 0})
                            ]);
                    end
                    
                    
                    %%%%%%%%%
                    % Replace non OR tags (tags have been verified here)
                    for ti = 1:length(tags)
                        if isempty(strfind(tagsfmt{ti},'|')) % exclude OR operators for now
                            ci = strcmp(obj.idhead, tags{ti}); % find col index of tag
                            if ~isempty(obj.iddata{ii,ci}) % only replace column if ID is not emtpy.
                                Format = strrep(Format, sprintf('<%s>',tagsfmt{ti}), obj.iddata{ii,ci});
                            end
                        end
                    end
                    
                    FormatLogical = {};
                    DLogical = {};
                    D = [];
                    % Now loop through logical tags
                    if contains(Format,'|') % if any tags contain OR operators loop through them, otherwise go straight to search
                        dfound = false; % Loop will skip once first file is found
                        for ti = 1:length(tags)
                            if contains(tagsfmt{ti},'|') && dfound == false % skip if file found already
                                ci = strcmp(obj.idhead, tags{ti}); % find col index of tag
                                if ~isempty(obj.iddata{ii,ci}) % only replace column if ID is not emtpy.
                                    FormatLogical = strrep(Format, sprintf('<%s>',tagsfmt{ti}), obj.iddata{ii,ci});
                                    [D, FormatLogical] = findfile(FormatLogical, obj.selectfirstfile);
                                    if ~isempty(D)
                                        dfound = true;
                                    end
                                end
                            end
                        end
                        Format = FormatLogical;
                    else
                        [D, Format] = findfile(Format, obj.selectfirstfile);
                    end
                    %%%%%%%%%
                    % Replace tags
                    %                     for ci = 1:length(obj.idhead)
                    %                         if ~isempty(obj.iddata{ii,ci}) % only replace column if ID is not emtpy.
                    %                             Format = strrep(Format,sprintf('<%s>',obj.idhead{ci}),obj.iddata{ii,ci});
                    %                         end
                    %                     end
                    %                     [D, Format] = findfile(Format, obj.selectfirstfile);
                    %
                    % Add Date Info
                    if ~isempty(D)
                        if ~isempty(D(1).datenum)
                            obj.fileinfo.(obj.searchpaths{sesi,1}).datestr{ii} = D.date;
                            obj.fileinfo.(obj.searchpaths{sesi,1}).datenum(ii) = D.datenum;
                        else
                            obj.fileinfo.(obj.searchpaths{sesi,1}).datestr{ii} = 0;
                            obj.fileinfo.(obj.searchpaths{sesi,1}).datenum(ii) = 0;
                        end
                        % Add correct IDs (probably not necessary unless >1 ID possible for each ID type
                        %             for tag = tags
                        %                 obj.CorrectID.(obj.searchpaths{sesi,1}).(tag{1})(ii) = obj.ID.(tag{1})(ii);
                        %             end
                    end
                    
                    % Figure out action to take
                    action = 0;
                    if size(D,1) == 1
                        action = 2; % only 1 result so return filepath
                    elseif size(D,1) == 0
                        action = 3; % no result, do nothing
                    elseif size(D,1) > 1
                        if ~obj.selectfirstfile
                            action = 1; % warn that multiple files exist
                        else
                            action = 4; % return the first file in list
                        end
                    end
                    
                    % Perform action
                    switch action
                        case 1 % multiple files
                            if obj.selectfirstfile == 1
                                lsOut = [fileparts(Format) D(ii).name];
                                obj.fileindexmat(ii,sesi) = true;
                                obj.filenames.(obj.searchpaths{sesi,1}){ii}; %#ok<VUNUS>
                                obj.fileindex.(obj.searchpaths{sesi,1})(ii,1) = 1;
                                if obj.listfound; fprintf('%s         \n', lsOut); end
                            else
                                warning(['The following files were found for your query: ' Format])
                                warning('Set obj.selectfirstfile = 1 if you want to use the first file');
                                dir(Format)
                                fprintf(1,'\n\n     ');
                            end
                            
                        case 2 % One file found
                            [folder, NULL, NULL] = fileparts(Format); %#ok<*NASGU>
                            lsOut = fullfile(folder,D.name);
                            obj.fileindexmat(ii,sesi) = true;
                            obj.filenames.(obj.searchpaths{sesi,1}){ii} = lsOut;
                            obj.fileindex.(obj.searchpaths{sesi,1})(ii,1) = 1;
                            
                        case 3
                            % Do nothing
                            
                        case 4 % Select first file from multiple files found
                            D = D(1);
                            [folder, NULL, NULL] = fileparts(Format);
                            lsOut = fullfile(folder,D.name);
                            obj.fileindexmat(ii,sesi) = true;
                            obj.filenames.(obj.searchpaths{sesi,1}){ii} = lsOut;
                            obj.fileindex.(obj.searchpaths{sesi,1})(ii,1) = 1;
                    end
                    
                    if obj.listfound && (action == 2 || action == 4)
                        disp('      ');
                        disp(lsOut);
                    end
                    
                end
                
                fprintf(1,['\nTotal files found: ' num2str(sum(obj.fileindexmat(:,sesi))) '\n\n--------------------------\n\n']);
                if sum(obj.fileindexmat(:,sesi)) == 0
                    warning('Check your file paths and that you have used the correct ID type')
                    disp(['The last path searched for was ' Format])
                    disp('NOTE: In order to select only the first file from a list (such as a list of dicoms), set obj.selectfirstfile = 1')
                end
                
            end
            
            obj.allexist = find(all(obj.fileindexmat,2))';
            
            function [D, Format] = findfile(Format, FirstFile)
                [fol, NULL, NULL] = fileparts(Format);
                if obj.debug == true
                    fprintf('Search string %s \n\n              ',Format)
                end
                if contains(fol,'*') % use ls to get an exact folder path if folder contains * (slows the script down)
                    try
                        L = ls(Format); % use ls to get file list using * (because it doesn't work with dir if * is in path folder names)
                        L = textscan(L,'%s');
                        L = L{1};
                        
                        if length(L) > 1 % there will only be a > 1 line feed if multiple items found.
                            % if more than one line then either warn user or just pick first file based on value in obj.selectfirstfile
                            if FirstFile == 1
                                L = L(1);
                            else
                                warning('More than one file found. Set obj.selectfirstfile = 1 if you want to use the first file');
                            end
                        end
                        D = dir(L{1}); % Once the path has been worked out, then use dir, which gives the proper D structure.
                        Format = L{1};
                    catch %#ok<*CTCH>
                        D = []; % no file found (ls annoyingly causes an error if no file was found).
                    end
                else
                    % no need for ls (faster)
                    D = dir(Format);
                end
            end
        end
    end
end